# ROART: Range-query Optimized Persistent ART

范围查询优化的持久前缀树

(i) 提出了一个叶压缩（leaf compaction）方法来减少范围查询时的指针追逐（指针跳转次数）
(ii) 减少持久性开销与三个优化，即条目压缩，选择性元数据持久性和最低顺序分裂（减少指令顺序限制）（entry compression, selective metadata persistence and minimally ordered split）
(iii) 设计一个快速内存管理以防止内存泄漏，并消除长恢复时间通过提出一个**即时重启策略** instant restart strategy。

评估表明，ROART分别比最先进的半径树分别高出1.65×和B+-Trees的1.17∼8.27×。

任何为实际应用设计的索引结构都应该考虑这三个方面: 功能性、性能、正确性

1. 功能性
   1. 变长key方面
   2. 范围查找
2. 崩溃一致性方面
   1. 垃圾回收

根据我们的实验（2.1），B+-Trees可能不是可变大小键的最佳性能索引。因此，我们选择radix树作为我们的基础，它**天然支持变长键**。

为了**改进范围查询**，我们提出了叶子压缩(LC)，它可以**延迟叶子分割，并将多个叶子节点压缩成一个叶子数组**。这种技术的好处有三方面：1）它减少了在范围查询期间的指针追逐（即减少了NVM的随机读）；2）它可以减少复杂的分割操作的数量；3）它倾向于降低树的高度，这有利于所有的索引操作。

正确性方面：1）使用ntstore，保证持久化；内存安全方面：2）即时重启，提高恢复效率；3）并发垃圾回收

## 功能性

### 变长key方面

许多持久的B+-Tree索引在节点数组中保持固定大小的（8字节键和8字节值）条目，如NVTree[3]、wB+-Tree[2]、FPTree[4]、RNTree[7]和LB+-Tree[9]，并且条目被附加到数组中。FAST&FAIR[5]也只支持固定的8字节键，如果**多个键和值在同一个缓存行中，它可以减少clwbs的数量**。这些B+-Trees具有**良好的缓存局部性**和仅基于优化8字节键的高遍历性能。

通常支持变长key的方法是，在定长key后面添加一个额外的指针，但这会导致：查找时更多的指针追逐，插入时更多的持久化操作，导致性能下降。

Radix Tree天然支持变长key，但范围查找上效率低，下面说明。

### 范围查找

B+-Trees支持有效的范围查询，因为多个键存储在一个叶节点中，并且在叶节点中的扫描不会导致指针跟踪。

但对于其他数据结构，比如Radix Tree和二叉树，一个节点只能存储一个键，键可以存储在叶节点中，也可以存储在非叶节点中。对这些树的范围查询必须遍历树的不同级别，并追逐更多的指针。**导致更多的NVM随机读取**。

但是，**当同时需要可变大小的键和范围查询时，B+-Trees可能不是索引的最佳选择**。在图1中，当使用可变大小的键时，B+-Trees的扫描吞吐量降低了48.5%。在3中，我们优化了自适应基数树(ART)。

> 所以说，在定长key和支持范围查找时，b+树的比较理想的选择。

## 崩溃一致性方面

正确的NVM分配器可以分为两类，**基于日志记录的分配器[51–53]和崩溃后的GC[22,54-56]**。前者使用日志记录来确保操作的原子性，从而引入了额外的持久性开销。后者通过**在恢复过程中扫描所有的内存空间来回收垃圾数据**。

后者分配释放性能高，但重启恢复的时间长。随着数据量的增加而增加

### 垃圾回收

许多索引都支持非阻塞查找[60–62]，以提高读取性能。在这种实现中，延迟GC机制是必要的。要删除的项目首先被标记为逻辑删除，然后再被物理删除，以避免从其他线程进行危险的并发访问。**在一个时间宽限期之后，GC线程会扫描并收集逻辑上删除的项目**。

例如，基于历元的GC[63]是懒惰GC[60,61,64]的常用策略。然而，基于易失性的基于epoch的GC实现可能会在NVM中导致内存泄漏，因为它不会持久化已标记的垃圾数据的元数据。重启后，这些垃圾数据将无法访问。


