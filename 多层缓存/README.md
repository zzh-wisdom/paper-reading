# README

## Multi-tier buffer management and storage system design for non-volatile memory（2019）

在本文中，我们提出了管理和设计由DRAM、NVM和SSD2组成的多层存储层次结构的技术。我们提出了一套优化方法来最大化d的效用在存储层次结构中的不同设备之间进行的迁移。这些优化是通过引入NVM来实现的。例如，由于DBMS可以直接操作nvm驻留的数据，因此buffer管理器不需要急切地将数据从NVM复制到DRAM。我们的结果表明，这种**惰性的数据迁移技术确保了只有频繁引用的数据被提升到DRAM**。

我们通过引入一种用于数据迁移优化的分类法来解决这个问题，该分类法包含了以前系统中使用的特定技术。我们举例说明了**缓冲区管理策略必须根据设备和工作负载特性进行定制**。鉴于此，我们在缓冲区管理器中提出了一种自适应机制，称为**自适应数据迁移**，以实现一个近似最优的用于任意工作负载和存储层次结构的缓冲区管理策略，而不需要任何手动调整。先前关于nvm感知存储管理的研究并没有解决设计中的问题针对目标工作负载和系统成本预算[11,24,32,34,45,56]的多层存储系统。

1. 我们介绍了一个针对nvm感知的数据迁移优化的分类法，并提出了一个用于管理多层存储层次结构的策略（第3节）。
2. 我们在缓冲区管理器中引入了一种自适应机制，它为任何工作负载和存储层次结构实现了一个接近最优的策略，而不需要任何手动调优（第4节）。
3. 我们介绍了一个为目标工作负载和系统成本预算设计多层存储层次结构的推荐系统（第5节）。

然而，**由于三个因素，很难部署高容量的DRAM系统**。首先，它推高了系统的总成本，因为它比二级存储技术要贵50倍。第二，增加DRAM容量会提高系统的总功耗。Lefurgy等人报告说，在商业服务器中，多达40%的系统总能量是由DRAM消耗的[36]。最后，由于在前几代产品中使用的扩展技术的限制，DRAM的扩展面临着巨大的挑战。晶体管和电容[42]。

数据从NVM迁移到DRAM的概率D小于1，实现惰性迁移。D取决于：工作集大小，DRAM和NVM缓冲区的容量之间的比率，

通过一个自适应策略，调整系统到接近最优水平。
探索不同的数据路径，通过数据建模，随机探测的方式找局部最优解，太数学了

## NyxCache-fast22

Optane DC PMM 表现出高度不对称的读取与写入性能（对于单个 DC PMM，最大读取带宽为 6.6GB/s，而最大写入带宽为 2.3GB/s）[45],读取和写入之间严重且不公平的干扰（以 1GB/s 写入会导致与以 8GB/s 读取相同的吞吐量和 P99 延迟减慢到共同运行的读取工作负载）[55]，尤其是对 256B [73] 的倍数。

该论文主要针对多租户情况下的pm cache机制。与我们研究的方向不太相关。

## eMRC: Efficient Miss Ratio Approximation for Multi-Tier Caching（fast21）

面向多租户，理论分析多层cache。只考虑不同层之间存在容量和性能差异，并没有考虑更微观的因素，如访问大小，访问模式等等。主要的目的是提高命中率，而忽略总体性能指标。

## Segcache（NSDI21）

分析发现，cache的对象通常很小，10s to 1000s of bytes，而常用的memcache却需要50B左右的空间为每个对象维护元数据，造成很高的空间占用。

现有的系统在存储小对象时并不高效，因为它们为每个对象存储了大量的元数据。例如，Memcached在每个对象中存储56字节的元数据，与典型的对象大小相比，这是一个很大的开销。所有的元数据字段对于Memcached的操作都是至关重要的，如果不首先删除一些功能或特性，就不能放弃。

Segcache是一个以TTL为索引的、动态分区的、分段结构的1缓存，其中TTL相似的对象被存储在一个固定大小的小日志中，称为分段。分段首先按TTL分组，然后按创建时间自然排序。这种方式使得及时清除过期的对象既简单又便宜。作为一个缓存，Segcache通过将几个段合并成一个段，只保留最重要的对象，并释放其余的对象来执行驱逐。**在段的层面上管理对象的生命周期**，允许大多数元数据在一个段内共享。它还允许用有限的微小的关键段来进行元数据的记账。这些决定提高了内存效率和可扩展性，而不牺牲吞吐量或功能。

> TTL是在写入时指定的，以确定一个对象在缓存系统中应保持多长时间的可访问性。一个过期的对象不能被返回给客户端，而会有一个缓存错过。这么说TTL我们用不上。

作为实时服务基础设施的重要组成部分，缓存更倾向于在DRAM中存储数据，特别是小对象。DRAM是昂贵的、耗能的。然而，现有的系统并没有有效地使用昂贵的DRAM空间。这种低效率主要来自于三个方面。首先，现有的解决方案不能够快速删除过期的对象。第二，与典型的对象大小相比，元数据的开销是相当大的。第三，内部或外部的内存碎片很常见，导致了空间的浪费。虽然接纳[24, 25, 39, 40, 43]、预取[73, 74]和驱逐算法[22, 23, 26, 30, 36, 37, 49, 68]的改进是现有工作中提高内存效率的主要重点[22, 25, 26, 39]，但很少有人关注解决过期和元数据的减少[41, 63]。

**懒惰的过期**意味着只有当一个对象被重新访问时才会过期。访问时删除是许多生产型缓存系统所采用的最直接的方法。如果一个系统只使用懒惰过期，**一个不再被访问的对象就会在过期后很长一段时间内留在内存中**。

设计：

我们将TTL范围t1到t2（t1<t2）的时间宽度定义为t2-t1。在t1到t2范围内的所有对象都被视为具有TTL t1，这是该范围的近似TTL。四舍五入保证了一个对象只能提前过期，并且没有对象会在过期后被提供。对象被分组为固定大小的小组，称为seg-ments（见下一节），所有存储在同一区段的对象具有相同的近似TTL。

> 用户指定明确的TTL，左右跟我们常规的使用方式不太一样。

**小对象合并驱逐，选择性保留部分对象：**

与大多数现有系统按对象进行驱逐不同，Segcache按段进行驱逐。分段驱逐可能会驱逐受欢迎的对象，增加失误率。为了解决这个问题，Segcache使用了一种基于合并的驱逐算法。其基本思想是，通过将多个seg-ments合并成一个，Segcache有选择地保留相对较小的一部分更有可能被再次访问的对象，而丢弃其余的。这个设计带来了几个更精细的设计决定。首先，我们需要挑选要合并的片段。其次，需要有一个算法在浏览这些片段时对每个对象进行决策。

**提到一些新颖的计数器算法**

## Efficient and Consistent NVMM Cache for SSD-Based File System（期刊杂志2019）

这个研究方向比较对口。可以学习。

背景：

- 使用NVM作为SSD的buffer/cache能避免小写造成SSD的读改写，提高性能
- 通过缓冲，大大减少SSD的写入流量，对于倾斜的负载能节约大部分流量（猜），延长SSD寿命


